= Grundlagen interne Servicekommunikation: Inhalt
include::{isy-dokumentvorlagen}/docs/common/isyfact-attributes.adoc[]

// tag::inhalt[]
[[grundlagen]]
== Grundlagen

In diesem Abschnitt beschreiben wir die Grundlagen der Kommunikation innerhalb der Plattform.
Zunächst wird in Abschnitt <<interne-und-externe-servicekommunikation>> die Unterscheidung von internen und externen Services geschärft und zentrale Begriffe eingeführt.
Danach wird in Abschnitt <<synchrone-kommunikation>> vorgestellt, wie synchrones und asynchrones Verhalten von Services abgebildet wird.
In Abschnitt <<technologie>> gehen wir dann auf die technische Umsetzung von Services ein.

=== Interne und externe Servicekommunikation
NOTE: Verschoben nach <<IsyFactReferenzarchitektur>>

[[queueing]]
==== Queueing

Hierfür wird in der Fachanwendung für jedes asynchron aufzurufende Anwendungssystem eine eigene Queue angelegt.
Jede Queue enthält automatisch eine Standard-Exception-Queue, die ausschließlich Oracle-intern verwendet wird.
Die Fachanwendung erzeugt Nachrichten, die anschließend mit JAXB in XML umgewandelt und mit Spring-JMS in die passende Queue geschrieben werden.
Fremdsysteme können die Benachrichtigungen aus der Queue auslesen und verarbeiten.

:desc-image-SchemdarQueue: Schematische Darstellung der Queues
[id="image-SchemdarQueue",reftext="{figure-caption} {counter:figures}"]
.{desc-image-SchemdarQueue}
image::SchemdarQueue.png[align="center"]

Die Fremdsysteme erhalten explizite Datenbank-Berechtigungen auf ihre Queue zum Dequeuen.
Somit ist sichergestellt, dass kein System auf fremde Queues zugreifen kann und dass keine Benachrichtigungen erneut eingestellt werden können.
Da die Queue als Bestandteil der Fachanwendung angesehen wird und die Daten somit in der Datenhoheit der Fachanwendung liegen, sind Datenbank-Benutzer und -Rechte durch das Anwendungssystem und nicht durch das die Queue nutzende Fremdsystem zu vergeben.

Der Queue-Name erhält eine einstellige Versionsnummer.
Damit ist es möglich bei inkompatiblen Schnittstellenänderungen mehrere Versionen der Benachrichtigungsschnittstelle anzubieten.
Ändert sich die Signatur der Benachrichtigungsschnittstelle, dann wird eine neue Queue in der bestehenden Queue-Tabelle angelegt und der Versionsanteil hochgezählt.
Über die betriebliche Konfiguration kann gesteuert werden, in welche Queue-Version die Daten en-/dequeued werden.
Dieses Vorgehen hat den Vorteil, dass die Fachanwendung von den Fremdsystemen stark entkoppelt ist.
Die Fachanwendung kann für einen gewissen Zeitraum immer sowohl die alte Queue-Version als auch die neue Queue-Version bedienen – es wird jedoch immer nur eine Queue befüllt.

Die Umsetzung erfolgt mit dem Spring JMS Integration Framework.
Zusätzlich wird die Register-Factory-Bibliothek _rf-jmsutil_ zur Überwachung verwendet. 
Die Überwachung ist in Form von drei JMX-Parametern umgesetzt:

* *queueSize:* Gibt die aktuelle Größe der Queue an. 
* *maxRetries:* Gibt die höchste Anzahl an Retries für die Verarbeitung einer Benachrichtigung an.
* *maxAlter:* Gibt den Enqueue-Zeitpunkt der ältesten Benachrichtigung an.
Die Werte für die Parameter werden mit SQL-Select-Queries auf die entsprechenden Queue-Tabellen ermittelt.
Aus Performancegründen wird dabei stets auf die extra von Oracle bereitgestellen Views für Queue-Tabellen zugegriffen und nie direkt auf die Queue-Tabellen selbst.

Die Benachrichtigungen werden ohne _expiration time_ enqueued. 
D.h. eine automatische Löschung von alten, nicht abgeholten Benachrichtigungen wird nicht durchgeführt.

[[vorgaben-für-fremdsysteme]]
==== Vorgaben für Fremdsysteme

Die Fremdsysteme dürfen sich nicht auf die Reihenfolge der Nachrichten in der Queue verlassen.
Anhand des Zeitstempels (_JMSTimestamp_) kann jedoch eine Reihenfolge ermittelt werden.
Das Feld _JMSTimestamp_ wird beim Schreiben in die Queue automatisch von der Datenbank gesetzt.

Bei fachlichen Fehlern muss eine entsprechende Benachrichtigung (z.B. Logging) vorgenommen werden;
Bei technischen Fehlern muss eine erneute Verarbeitung ermöglicht werden z.B. indem die Nachricht in eine eigene „Fehlerqueue“ enqueued wird.
Die Oracle-AQ-Exception-Queue ist nicht zu verwenden.

Nachrichten enthalten als JMS-Properties den Aufrufkontext mit den Rollen, jedoch ohne die Korrelations-ID.
Der Aufrufkontext muss von dem aufrufenden System geprüft werden.
Das Feld _JMSCorrelationId_ wird mit der Korrelations-ID befüllt.

[[nachrichteninhalt]]
==== Nachrichteninhalt

Eine JMS-Message besteht aus (siehe _<<image-AufbJMSMesg>>: Aufbau der JMS-Message_)

* dem Message Header
* den Message Properties
* dem Message Body

:desc-image-AufbJMSMesg: Aufbau der JMS-Message
[id="image-AufbJMSMesg",reftext="{figure-caption} {counter:figures}"]
.{desc-image-AufbJMSMesg}
image::AufbJMSMesg.png[align="center",width=40%,pdfwidth=40%]

Über die Message-Properties wird der Aufrufkontext abgebildet, da es sich um die Kommunikation zwischen zwei Systemen
handelt und wie eine Außenschnittstelle zu betrachten ist.

Der Message-Body enthält die Benachrichtigung im XML-Format.
Für jedes Fremdsystem wird eine gesonderte XSD-Datenbeschreibung bereitgestellt, so dass jedes System eigene Nachrichten in
seinem Format erhalten kann.
Damit haben bspw. Änderungen der Nachrichten von Fremdsystem 1 keine Auswirkungen auf die Nachrichten von Fremdsystem 2.

=== Technologie
NOTE: Verschoben nach <<KonzeptHttpInvoker>>.

[[versionierung]]
== Versionierung
NOTE: Verschoben nach <<DetailkonzeptKomponenteService>>.

[[verfuegbarkeit]]
== Verfügbarkeit
NOTE: Verschoben nach <<DetailkonzeptKomponenteService>>
// end::inhalt[]