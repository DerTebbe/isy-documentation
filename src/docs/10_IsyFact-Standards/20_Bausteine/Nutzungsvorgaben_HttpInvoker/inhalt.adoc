= Nutzungsvorgaben HTTP Invoker: Inhalt
include::{isy-dokumentvorlagen}/docs/common/isyfact-attributes.adoc[]

// tag::inhalt[]
[[maven-konfiguration]]
== Maven-Konfiguration

Zur Verwendung des Bausteins HTTP Invoker genügt es, die folgenden zwei Bibliotheken aus der IsyFact als Maven-Abhängigkeiten einzubinden.

:desc-listing-pom: Einbindung des Bausteins HTTP Invoker
[id="listing-pom",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-pom}
[source,xml]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>de.bund.bva.isyfact</groupId>
            <artifactId>isy-serviceapi-core</artifactId>
        </dependency>
        <dependency>
            <groupId>de.bund.bva.isyfact</groupId>
            <artifactId>isy-serviceapi-sst</artifactId>
        </dependency>
    </dependencies>
</dependencyManagement>
----


[[realisierung-remote-bean]]
== Realisierung des Remote-Beans

Das Remote-Bean wird als Java-Schnittstelle realisiert.
Jede Methode entspricht dabei einem möglichen Service-Aufruf.
Jede Methode der RemoteBean-Schnittstelle muss als ersten Parameter ein Objekt der Klasse `AufrufKontextTo` bzw. `ClientAufrufKontextTo` verwenden.
Dieser Parameter dient dazu, Meta-Informationen zum jeweiligen Aufruf zu übergeben.
Daneben enthält die Schnittstelle natürlich noch weitere, fachliche Parameter, die frei definiert werden können.

Die Verwendung von Parametern in einer Schnittstelle ist im folgenden Beispiel dargestellt:

:desc-listing-BSPRemoteBean: Beispiel für ein Remote-Bean
[id="listing-BSPRemoteBean",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BSPRemoteBean}
[source,java]
----
public class BeispielRemoteBean {
     public BeispielHolenAntwortTo holeBeispielAnfrage(
         AufrufKontextTo kontext, BeispielHolenAnfrageTo anfrage)
         throws BeispielTechnicalToException;
}
----

Im Folgenden werden die beiden Klassen `AufrufKontextTo` und `ClientAufrufKontextTo` näher beschrieben.

*AufrufKontextTo:* Die Klasse `AufrufKontextTo` wird für HTTP Invoker Schnittstellen verwendet, die durch IT-Systeme definiert werden.
Die Klasse kapselt die Informationen, mit denen andere IT-Systeme aufgerufen wurde:

** *Behörde:* Das Behördenkennzeichen der aufrufenden Behörde,
** *Kennung:* Die Kennung des aufrufenden Benutzers oder des aufrufenden Fremdprogramms,
** *Kennwort:* Das Passwort des aufrufenden Benutzers oder des aufrufenden Fremdprogramms,
** *Rollen:* Die Rollen des aufrufenden Benutzers oder des aufrufenden Fremdprogramms,
** *Korrelations-ID:* Die ID, um den Service-Aufruf eindeutig zu identifizieren.

*ClientAufrufKontextTo:* Die Klasse `ClientAufrufKontextTo` wird für HTTP Invoker Schnittstellen verwendet, die durch Service-Consumer definiert werden.
Im Gegensatz zu `AufrufKontextTo` kapselt diese Klasse die Informationen, um sich bei einem externen Service zu authentifizieren und zu autorisieren:

** *Kennung:* Die Kennung mit welcher der externe Service aufgerufen wird,
** *Kennwort:* Das Passwort mit welchem der externe Service aufgerufen wird,
** *Zertifikat:* Das Zertifikat, um sich beim externen Service zu authentifizieren,
** *Zertifikat-Kennwort:* Das Passwort des Zertifikats für die Authentifizierung.

Sowohl `AufrufKontextTo` als auch `ClientAufrufKontextTo` sind in der Bibliothek `isy-serviceapi-sst` definiert.


[[realisierung-exception-fassade]]
== Realisierung der Exception-Fassade

Die Exception-Fassade implementiert das Remote-Bean-Interface und definiert in jeder Methode einen `try`-`catch`-Block, der alle Fehler des Anwendungskerns abfängt und in Fehler der Service-Schnittstelle umwandelt.

In <<listing-BSPExceptionFassade>> ist ein Beispiel für eine Exception-Fassade eines IT-Systems angegeben.
Die Service-Operationen sind in diesem Fall die Methoden des Interfaces `BeispielRemoteBean`.
Konkret handelt es sich lediglich um die Service-Operation `holeBeispielAnfrage`.
Die Service-Operation ist mit der Annotation `@StelltLoggingKontextBereit` versehen, die eine mit dem `AufrufKontext` übergebene Korrelations-ID im Logging-Kontext registriert und diesen beim Verlassen der Methode wieder aufräumt.

NOTE: Falls im AufrufKontext keine Korrelations-ID vorhanden ist, so erzeugt die Annotation eine neue Korrelations-ID.

Es ist wichtig den Logging-Kontext zu setzen, bevor die Exception-Fassade aktiv wird.
Die Implementierung der Service-Operation reicht den Methodenaufruf an die implementierende Klasse (`BeispielService`) weiter, fängt auftretende Fehler jedoch über einen `try`-`catch`-Block ab.
Der `try`-`catch`-Block unterscheidet zwischen Exceptions der Datenbankzugriffsschicht (`DataAccessException`) und allen anderen Exceptions (`Throwable`), um einen passenden Fehlertext in die Log-Dateien zu schreiben.

:desc-listing-BSPExceptionFassade: Beispiel für eine Exception-Fassade
[id="listing-BSPExceptionFassade",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BSPExceptionFassade}
[source,java]
----
public class BeispielExceptionFassade implements BeispielRemoteBean
{
    private static final IsyLoggerStandard logger = ...;
    private BeispielService beispielService;
    ...
    @StelltLoggingKontextBereit
    public BeispielHolenAntwortTo holeBeispielAnfrage
        (AufrufKontextTo kontext, BeispielHolenAnfrageTo anfrage)
        throws BeispielTechnicalToException {
        try {
            return beispielService.holeBeispielAnfrage(kontext,anfrage);
        } catch (DataAccessException e) {
            logger.error("Fehler bei Transaktion", e);
            throw new BeispielTechnicalToException(...);
        } catch (Throwable t) {
            logger.error("...", t);
             throw new BeispielTechnicalToException(...);
        }
    }
    ...
}
----


[[realisierung-service-fassade]]
== Realisierung der Service-Fassade

Die Service-Fassade übernimmt die restlichen Aufgaben der Service-Logik, d.h. Transformation der Transportobjekte in Objekte des Anwendungskerns und umgekehrt, sowie die Autorisierung des Aufrufs.

In <<listing-BSPServiceFassade>> ist ein Beispiel für eine Service-Fassade angegeben.
Die Implementierung der Service-Fassade erfolgt analog zur Implementierung der Exception-Fassade.
Die nach außen angebotene Service-Operation (`holeBeispielAnfrage`) wird jedoch nicht eins-zu-eins an die implementierende Klasse weitergeleitet, da sich die Parameter und der Rückgabewert des Aufrufs unterscheiden.
Nach außen hin werden Transportobjekte angeboten.
Intern arbeitet die Anwendung mit ihren eigenen Entitäten.
Diese können sich von den nach außen hin angebotenen Transportobjekten unterscheiden, z.B. weil sie zusätzliche Attribute enthalten, einzelne Attribute anders benennen oder die Daten in irgendeiner Form anders repräsentieren als die Transportobjekte.

In der Service-Fassade erfolgt auch die Autorisierung eines Zugriffs auf eine Service-Methode.
Voraussetzung für die Autorisierung ist die Auswertung des mitgelieferten AufrufKontextes über die
Annotation `@StelltAufrufKontextBereit` aus der Bibliothek `isy-serviceapi-core` an der Service-Methode.
Anschließend kann über die Annotation `@Gesichert` der Bibliothek `isy-sicherheit` die Berechtigung zum Zugriff auf die Methode geprüft werden.
Hier werden alle benötigten Rechte des Aufrufers überprüft.
Alternativ kann die Annotation `@Gesichert` auch an der Service-Klasse verwendet werden, wenn alle Methoden die gleiche Autorisierung erfordern.

Das Mapping im Beispiel wird durch einen Bean Mapper umgesetzt.
Vor dem Aufruf werden die Parameter gemappt (Klasse `BeispielHolenAnfrageTo` auf Klasse `BeispielHolenAnfrage`),
nach dem Aufruf der Rückgabewert (Klasse `BeispielHolenAntwort` auf Klasse `BeispielHolenAntwortTo`).

Die Komponente Service-Logik wird durch eine entsprechende Spring-Konfigurationsklasse verschaltet.

:desc-listing-BSPServiceFassade: Beispiel für eine Service-Fassade
[id="listing-BSPServiceFassade",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-BSPServiceFassade}
[source,java]
----
public class BeispielServiceFassade {
    private static final IsyLoggerStandard logger = ...;

    private MapperFacade beanMapper;
    private Beispiel beispiel;

    @StelltAufrufKontextBereit
    @Gesichert(Rechte.RECHT_ZUGRIFFBEISPIEL)
    public BeispielHolenAntwortTo holeBeispielAnfrage(
        AufrufKontextTo kontext, BeispielHolenAnfrageTo anfrage) {

        try {
            BeispielHolenAnfrage anfrageAwk = beanMapper.map(anfrage, BeispielHolenAnfrage.class);
            BeispielHolenAntwort antwortAwk = beispiel.holeBeispielAnfrage(anfrageAwk);

            return beanMapper.map(antwortAwk, BeispielHolenAntwortTo.class);
        } catch (MappingException e) {
            logger.error("...", e);
            throw new TechnicalException(...);
        }
	...
}
----


[[realisierung-to]]
== Realisierung von Transportobjekten

Transportobjekte dürfen keine externen Abhängigkeiten haben, da sie Teil der ausgelieferten Schnittstelle sind.
Bei Transportobjekten ist zu beachten, dass die UID stets 0 ist (s. <<listing-to-uid>>).

:desc-listing-to-uid: Definition der UID an Transportobjekten
[id="listing-to-uid",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-to-uid}
[source,java]
----
public class BeispielTransportobjekt {
    private static final long serialVersionUID = 0L;
}
----

[[paketierung]]
== Paketierung einer Service-Schnittstelle

IT-Systeme teilen sich folgende Java-Klassen der HTTP Invoker Schnittstelle:

* Java-Interface der Schnittstelle (Remote-Bean),
* Java-Klassen der Transportobjekte,
* Java-Klassen der Transport-Exceptions.

Diese Klassen müssen als JAR mit einer einzigen Abhängigkeit auf die Bibliothek `isy-serviceapi-sst` paketiert werden.
Sie werden anhand der Vorgaben in <<DetailkonzeptKomponenteService>> und <<IsyFactVersionierung>> versioniert und anhand der Vorgaben in <<IsyFactNamenskonventionen>> benannt.

[[nutzung]]
== Nutzung einer Service-Schnittstelle

Zur Nutzung einer entfernten Schnittstelle bindet ein IT-System das JAR der Schnittstelle via Maven ein und
initialisiert die Remote-Beans damit.
Das geschieht über die vom Spring Framework bereitgestellte Factory-Klasse `HttpInvokerProxyFactoryBean`, wie in <<listing-invokerconfig>> dargestellt.
Auf dieser Bean können dann die entfernten Methoden aufgerufen werden.

:desc-listing-invokerconfig: Konfiguration für die Nutzung einer entfernten Schnittstelle
[id="listing-invokerconfig",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-invokerconfig}
[source,java]
----
@Configuration
public class ServiceConfiguration {

    @Bean
    public HttpInvokerProxyFactoryBean beispielRemoteBean(HttpInvokerRequestExecutor executor, ServiceConfigProperties config) {
        HttpInvokerProxyFactoryBean invoker = new HttpInvokerProxyFactoryBean();
        invoker.setServiceUrl(config.getServiceUrl());
        invoker.setServiceInterface(BeispielRemoteBean.class);
        invoker.setHttpInvokerRequestExecutor(executor);
        return invoker;
    }

    @Bean
    public TimeoutWiederholungHttpInvokerRequestExecutor executor(ServiceConfigProperties config) {
        TimeoutWiederholungHttpInvokerRequestExecutor executor = new TimeoutWiederholungHttpInvokerRequestExecutor();
        executor.setAnzahlWiederholungen(config.getWiederholungen());
        executor.setTimeout(config.getTimeout());
        return executor;
    }

----

Die FactoryBean erwartet eine Service-URL und ein Remote-Bean-Interface zur Initialisierung.
Der Host-Teil der URL muss in jedem Fall in der betrieblichen Konfiguration der Anwendung zu finden sein.
Das Remote-Bean-Interface ist im Schnittstellen-JAR verfügbar.

Die Nutzung des hier im Beispiel verwendeten `TimeoutWiederholungHttpInvokerRequestExecutor` ist optional.
Dieser Executor bricht nach dem angegebenen Timeout die Anfrage ab und wiederholt sie bis zur maximalen angegebenen
Wiederholungsanzahl.

Nutzt das IT-System den Baustein Logging, muss statt der Spring-eigenen Factory die erweiterte `IsyHttpInvokerProxyFactoryBean` genutzt werden.
Sie versieht die Remote-Beans automatisch mit einem `LogMethodInterceptor`, der die Aufrufzeiten der ausgehenden Aufrufe misst und loggt.
Die Konfiguration erfolgt wie in <<listing-isyinvokerconfig>> gezeigt.

:desc-listing-isyinvokerconfig: Konfiguration mit IsyHttpInvokerProxyFactoryBean
[id="listing-isyinvokerconfig",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-isyinvokerconfig}
[source,java]
----
@Bean
public IsyHttpInvokerProxyFactoryBean beispielRemoteBean(HttpInvokerRequestExecutor executor, ServiceConfigProperties config) {
    IsyHttpInvokerProxyFactoryBean invoker = new IsyHttpInvokerProxyFactoryBean();
    invoker.setServiceUrl(config.getServiceUrl());
    invoker.setServiceInterface(BeispielRemoteBean.class);
    invoker.setHttpInvokerRequestExecutor(executor);
    invoker.setRemoteSystemName(config.getRemoteSystemName());
    return invoker;
}
----

Die erweiterte FactoryBean erwartet nur einen zusätzlichen Parameter `remoteSystemName`.
Dieser wird genutzt, um in allen Log-Ausgaben einen sprechenden Systemnamen zu setzen.

// end::inhalt[]