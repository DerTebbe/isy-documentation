= Nutzungsvorgaben Sicherheit: Inhalt
include::../../../common/isyfact-attributes.adoc[]
include::../../../common/attributes.adoc[]

// tag::inhalt[]
[[grundkonzepte-und-konfiguration]]
== Grundkonzepte und Konfiguration
Der Baustein Sicherheit definiert in der Bibliothek `isy-sicherheit` folgende, zentrale Schnittstellen:

* `Sicherheit`: Einstiegspunkt in die Bibliothek
* `Berechtigungsmanager`: Zugriff auf Informationen zur Berechtigung einzelner Anwender (Rollen & Rechte)

[IMPORTANT]
====
Wie im <<KonzeptSicherheit>> beschrieben, fokussiert sich die Bibliothek `isy-sicherheit` auf die Zuordnung von Rechten zu Anwendern anhand ihrer Rollen.
Die Authentifizierung und die Auflösung der Rollen geschieht in einem anderen Baustein der IsyFact und kann für die Benutzung der Bibliothek als gegeben angenommen werden.
====

Die folgende Abbildung zeigt die Schnittstellen und ihre Verbindung untereinander.
Die zentrale Schnittstelle für den Zugriff auf Rollen und Rechte eines Anwenders ist der `Berechtigungsmanager`.
Instanzen dieser Schnittstelle zur Autorisierung einer Anfrage werden über die Schnittstelle `Sicherheit` erzeugt.

:desc-image-schnittstellen-baustein: Schnittstellen des Bausteins Sicherheit
[id="image-schnittstellen-baustein",reftext="{figure-caption} {counter:figures}"]
.{desc-image-schnittstellen-baustein}
image::sicherheit_002.png[align="center"]

Ein `Berechtigungsmanager` gibt Instanzen der Schnittstellen `Recht` und `Rolle` zurück.
Anwender bekommen Rollen bereits an anderer Stelle zugewiesen.
Für den Baustein Sicherheit ist diese Zuordnung fest vorgegeben und nicht änderbar.
Anhand seiner Rollen werden dem Anwender durch das IT-System Rechte zugewiesen.
Diese Zuordnung erfolgt über <<konfiguration-von-rollen-in-der-anwendung,eine Konfigurationsdatei>>.

Die Implementierung des Aufrufkontextes richtet sich nach dem verwendeten IsyFact-Baustein zur Authentifizierung.

[[maven-konfiguration]]
=== Maven-Konfiguration
Zur Verwendung des Bausteins Sicherheit genügt es, die folgenden zwei Bibliotheken aus der IsyFact als Maven-Abhängigkeiten einzubinden.

:desc-listing-pom: Einbindung des Bausteins Sicherheit
[id="listing-pom",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-pom}
[source,xml]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>de.bund.bva.isyfact</groupId>
            <artifactId>isy-sicherheit</artifactId>
        </dependency>
        <dependency>
            <groupId>de.bund.bva.isyfact</groupId>
            <artifactId>isy-aufrufkontext</artifactId>
        </dependency>
    </dependencies>
</dependencyManagement>
----

[[spring-konfiguration]]
=== Spring-Konfiguration

Zur Konfiguration der zentralen Schnittstellen müssen Spring Beans definiert werden.

[TIP]
====
Üblicherweise geschieht dies in der separaten Spring-Konfigurationsdatei `/resources/spring/querschnitt/sicherheit.xml`.
Diese Konfigurationsdatei wird üblicherweise in eine zentrale Spring-Konfigurationsdatei für den Querschnitt (`/resources/spring/querschnitt.xml`) eingebunden.
====

Am Wichtigsten ist die Definition der Spring Bean für die Schnittstelle `Sicherheit`.

:desc-listing-spring-konfiguration-sicherheit: Spring-Konfiguration der Schnittstelle Sicherheit
[id="listing-spring-konfiguration-sicherheit",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-spring-konfiguration-sicherheit}
[source, xml]
----
<beans>
    <bean id="sicherheit" class="de.bund.bva.pliscommon.sicherheit.impl.SicherheitImpl">
        <property name="rollenRechteDateiPfad" value="/resources/sicherheit/rollenrechte.xml"/>
        <property name="aufrufKontextVerwalter" ref="aufrufKontextVerwalter"/>
        <property name="accessManager" ref="accessManager"/>
        <property name="konfiguration" ref="konfiguration"/>
        <property name="aufrufKontextFactory" ref="aufrufKontextFactory"/>
    </bean>

    <bean id="sicherheitAdmin" class="de.bund.bva.pliscommon.sicherheit.impl.SicherheitAdminImpl">
        <property name="accessManager" ref="accessManager"/>
    </bean>

    <bean id="aufrufKontextFactory" class="de.bund.bva.pliscommon.aufrufkontext.impl.AufrufKontextFactoryImpl">
        <property name="aufrufKontextKlasse" value="de.bund.bva.pliscommon.aufrufkontext.impl.AufrufKontextImpl"/>
    </bean>

    <bean id="aufrufKontextVerwalter" scope="thread" class="de.bund.bva.pliscommon.aufrufkontext.impl.AufrufKontextVerwalterImpl">
        <aop:scoped-proxy/>
    </bean>

    <bean id="accessManager" class="..." />
</beans>
----

Hierbei werden auch direkt die Spring Beans zur Verwaltung der Aufrufkontexte und zur Überwachung des Bausteins konfiguriert.

[IMPORTANT]
====
Die Implementierung der Schnittstelle `AccessManager` stellt einer der IsyFact-Bausteine für die Authentifizierung bereit.
Eine Beschreibung der Konfiguration findet sich in den jeweiligen Nutzungsvorgaben.
====

==== Caching von Authentifizierungen

Der Baustein liefert eine <<standard-cache-konfiguration,Standard-Konfiguration für das Caching von Authentifizierungen>> an.
Der Standardwert für die Lebensdauer von Cache-Elementen liegt bei 5 Minuten, die maximale Anzahl an Elementen im Cache bei 1000.
Wird die maximale Anzahl an Elementen überschritten, löscht der Cache die am längsten nicht mehr verwendeten Elemente zuerst.

Die Werte für die Lebensdauer von Cache-Elementen sowie die maximale Anzahl an Elementen im Cache können über die betriebliche Konfiguration angepasst werden.
Hierzu sind folgende Parameter zu setzen:

:desc-listing-konfiguration-cache: Konfiguration des Caches für Authentifizierungen
[id="listing-konfiguration-cache",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-konfiguration-cache}
[source,java]
----
# Zeit in Sekunden, die ein Eintrag im Cache verweilt, bis er als ungültig markiert wird.
sic.caching.ttl=300

# Maximale Anzahl an Elementen, die im Cache vorgehalten werden.
sic.caching.max.elements=1000
----

Wird der Parameter `sic.caching.ttl` auf 0 gesetzt oder nicht konfiguriert, ist der Cache deaktiviert.
Wird der Parameter `sic.caching.max.elements` auf 0 gesetzt, werden beliebig viele Elemente im Cache vorgehalten.

Ist die Standard-Konfiguration nicht ausreichend, kann der Cache vollständig von außen konfiguriert werden.
Dazu muss der Parameter `cacheKonfiguration` der Bean `sicherheit` auf den Pfad zur Cache-Konfiguration gesetzt werden.

[[konfiguration-von-rollen-und-rechten]]
=== Konfiguration von Rollen und Rechten

Jede Fachanwendung spezifiziert im Rahmen ihrer Systemspezifikation Rechte und bildet diese auf fachliche und technische Rollen ab.
Bei der technischen Umsetzung müssen alle spezifizierten Rollen und Rechte konfiguriert und korrekt zugeordnet werden.
Dies geschieht in der statischen Konfiguration in der Datei `/resources/sicherheit/rollenrechte.xml`.
Der Baustein liefert ein <<rollen-rechte-schema,XML-Schema für den Aufbau der Konfigurationsdatei>> mit.

====
Die Fachanwendung X spezifiziert zwei Rechte, `DialogA.Aufrufen` und `DialogB.Aufrufen`.
Aus diesen werden zwei fachliche Rollen gebildet:

* `FAX_DialogNutzerA` darf nur Dialog A aufrufen,
* `FAX_DialogNutzerAlle` darf Dialog A und Dialog B aufrufen.

====

Dieses Beispiel führt zu folgender Konfigurationsdatei.

:desc-listing-RollenRechte: Beispielhafte Definition von Rollen und Rechten
[id="listing-RollenRechte",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-RollenRechte}
[source,xml]
----
<tns:Anwendung AnwendungsId="FachanwendungX"
    xmlns:tns="http://www.isyfact.de/RollenRechteSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.isyfact.de/RollenRechteSchema RollenRechteSchema.xsd ">

<!-- Definition der Rechte -->
<tns:rechte>
  <tns:rechtId Id="DialogA.Aufrufen" />
</tns:rechte>

<tns:rechte>
  <tns:rechtId Id="DialogB.Aufrufen" />
</tns:rechte>

<!-- Definition der Rollen -->
<tns:rollen RolleId="FAX_DialogNutzerA">
  <tns:rechtId Id="DialogA.Aufrufen" />
</tns:rollen>

<tns:rollen RolleId="FAX_DialogNutzerAlle">
  <tns:rechtId Id="DialogA.Aufrufen" />
  <tns:rechtId Id="DialogB.Aufrufen"/>
</tns:rollen>

</tns:Anwendung>
----

Innerhalb jeder Rolle werden gemäß Spezifikation die zugeordneten Rechte festgelegt.
Rollen können überlappende Teilmengen von Rechten enthalten.

Die Konfiguration muss die folgenden Anforderungen erfüllen:

* Es sind alle in der Fachanwendung spezifizierten Rechte definiert.
* Es sind alle in der Fachanwendung spezifizierten Rollen definiert.

Werden in Überprüfungen Rollen oder Rechte verwendet, die hier nicht definiert sind, so wird ein technischer Fehler erzeugt.
Die Konfiguration gibt also verlässlich Auskunft darüber, welche Rollen und Rechte in der Fachanwendung überprüft werden.

Der Baustein Sicherheit ermöglicht eine Autorisierung nur auf Basis von Rechten, nicht von Rollen.
Jeder Rolle muss also zumindest ein Recht zugeordnet werden, um anhand ihr eine Autorisierung durchführen zu können.
Werden im Lebens­zyklus der Fachanwendung weitere Rollen (z.B. für neu hinzukommende Akteure) spezifiziert und mit bestehenden Rechten  ausgestattet, so sind neben den Änderungen in der Konfigurationsdatei keine weiteren Änderungen notwendig.


[[autorisierung]]
== Umsetzung der Autorisierung

Die <<IsyFactReferenzarchitekturITSystem>> beschreibt drei Möglichkeiten des Zugriffs auf ein IT-System: Grafische Oberflächen (GUIs), Services und Batches.
Für alle diese Möglichkeiten gilt, dass der Aufrufkontext so früh wie möglich aus der eingehenden Anfrage auszulesen und im Verwalter (d.h. dem Spring Bean `AufrufKontextVerwalter`) zu speichern ist.
Nur so kann sichergestellt werden, dass alle Prüfungen auf Rechte korrekt funktionieren.
Dazu bietet der Baustein Sicherheit einige Hilfsmittel an.
Durch Verwendung dieser Hilfsmittel lässt sich die Autorisierung weitgehend deklarativ und transparent abwickeln.
Die Autorisierung wird zum Aspekt des Querschnitts und beschränkt sich auf deklarative Elemente des Quellcodes.
Fachliche Schnittstellen werden von Parametern befreit und Prüfungen auf vorhandene Rechte können nur schwer vergessen werden.

[[gui-autorisierung]]
=== Autorisierung in der GUI

Beim Aufruf grafischer Oberflächen wird der Aufrufkontext über einen `AbstractAuthenticationProcessingFilter` aus Spring Security ausgelesen.
Die Autorisierung geschieht auf Ebene der Flows aus Spring Webflow.
Weitere Details zur Umsetzung der Autorisierung in der GUI sind in <<DetailkonzeptKomponenteWebGUI>> beschrieben.

[[gui-spring-konfiguration]]
==== Spring-Konfiguration

Zur Absicherung der Flows sowie zum Auslesen des Aufrufkontextes ist folgende Spring-Konfiguration erforderlich.

:desc-listing-konfiguration-gui: Spring-Konfiguration für Autorisierung in der GUI
[id="listing-konfiguration-gui",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-konfiguration-gui}
[source, xml]
----
<beans>
    <sec:http auto-config="false"
        use-expressions="true"
        entry-point-ref="preAuthenticatedProcessingFilterEntryPoint"
        create-session="stateless">
        <sec:custom-filter ref="processingFilter" position="PRE_AUTH_FILTER"/>
    </sec:http>

    <bean id="preAuthenticatedProcessingFilterEntryPoint"
        class="org.springframework.security.web.authentication.Http403ForbiddenEntryPoint"/>

    <sec:authentication-manager alias="authenticationManager">
        <sec:authentication-provider ref="authenticationProvider"/>
    </sec:authentication-manager>

    <bean id="accessDecisionManager"
        class="de.bund.bva.pliscommon.sicherheit.web.DelegatingAccessDecisionManager">
        <property name="sicherheit" ref="sicherheit" />
    </bean>

    <bean id="authenticationProvider" class="..."/>
    <bean id="processingFilter" class="..." />
</beans>
----

Wichtig ist, dass sich der Filter an der Position `PRE_AUTH_FILTER` befindet.
Greift er nicht, weil z.B. keine gültige Authentifizierung vorliegt, wird die Anfrage direkt mit einem HTTP-Statuscode 403 (Forbidden) beantwortet.
Dies stellt das Bean `preAuthenticatedProcessingFilterEntryPoint` sicher.

[IMPORTANT]
====
Die Implementierung der Beans `authenticationProvider` sowie `processingFilter` stellt einer der IsyFact-Bausteine für die Authentifizierung bereit.
Eine Beschreibung der Konfiguration findet sich in den jeweiligen Nutzungsvorgaben.
====

[[gui-absicherung]]
==== Absicherung der Flows

Ein Webflow wird durch das Tag `<secured/>` abgesichert.
Das Tag kann den ganzen Flow, einzelne Zustände oder einzelne Transitionen betreffen und ermöglicht so eine feingranulare Vergabe von Rechten.
Im Parameter `attributes` stehen die für den Zugriff erforderlichen Rechte.

:desc-listing-absichern-eines-flow: Absichern eines Flow, Zustands und einer Transition
[id="listing-absichern-eines-flow",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-absichern-eines-flow}
[source, xml]
----
<flow>
    <secured attributes="DialogA.Aufrufen" />

    <view-state id="sichererZustand">
        <secured attributes="DialogA.Aufrufen" />
    </view-state>

    <transition on="sichererZustand" to="sichererZustand">
        <secured attributes="DialogA.Aufrufen, DialogB.Aufrufen" />
    </transition>
</flow>
----

[[service-autorisierung]]
=== Autorisierung an einer Service-Schnittstelle

Beim Aufruf von Service-Schnittstellen wird der Aufrufkontext über Annotationen und Interceptoren an den Service-Methoden ausgelesen.
Die Autorisierung geschieht ebenfalls auf Ebene der Service-Methoden.
Weitere Details zur Umsetzung der Autorisierung an Service-Schnittstellen sind in <<DetailkonzeptKomponenteService>> beschrieben.

[[service-spring-konfiguration]]
==== Spring-Konfiguration

Zur Absicherung der Service-Schnittstellen sowie zum Auslesen des Aufrufkontextes ist folgende Spring-Konfiguration erforderlich.

:desc-listing-konfiguration-service: Spring-Konfiguration für Autorisierung an Service-Schnittstellen
[id="listing-konfiguration-service",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-konfiguration-service}
[source, xml]
----
<beans>
    <bean id="aufrufKontextInterceptor"
        class="de.bund.bva.pliscommon.aufrufkontext.service.StelltAufrufKontextBereitInterceptor">
        <property name="aufrufKontextVerwalter" ref="aufrufKontextVerwalter"/>
        <property name="aufrufKontextFactory" ref="aufrufKontextFactory"/>
    </bean>
    <aop:config>
        <aop:pointcut id="aufrufKontextPointcut" expression="@annotation(de.bund.bva.pliscommon.aufrufkontext.service.StelltAufrufKontextBereit) || @within(de.bund.bva.pliscommon.aufrufkontext.service.StelltAufrufKontextBereit)"/>
        <aop:advisor pointcut-ref="aufrufKontextPointcut" advice-ref="aufrufKontextInterceptor"/>
    </aop:config>

    <bean id="gesichertInterceptor" class="de.bund.bva.pliscommon.sicherheit.annotation.GesichertInterceptor">
        <property name="sicherheit" ref="sicherheit"/>
        <property name="sicherheitAttributeSource">
          <bean class="de.bund.bva.pliscommon.sicherheit.annotation.AnnotationSicherheitAttributeSource"/>
        </property>
    </bean>
    <aop:config>
        <aop:pointcut id="gesichertPointcut" expression="@annotation(de.bund.bva.pliscommon.sicherheit.annotation.Gesichert) || @within(de.bund.bva.pliscommon.sicherheit.annotation.Gesichert)"/>
        <aop:advisor pointcut-ref="gesichertPointcut" advice-ref="gesichertInterceptor"/>
    </aop:config>
</beans>
----

[[service-absicherung]]
==== Absicherung der Service-Methoden

Im Gegensatz zu Aufrufen der grafischen Oberfläche werden bei Aufrufen von Service-Methoden keine HTTP-Header zum Transport des Aufrufkontextes verwendet.
Stattdessen wird der Aufrufkontext als Schnittstellenparameter in Form eines Transportobjekts mit jedem Aufruf übergeben.
Dieses Transportobjekt, eine Instanz der Klasse `AufrufKontextTo`, muss die Informationen zum anfragenden Anwender und dessen Rollen enthalten.

Die Annotation `@StelltAufrufKontextBereit` signalisiert einem Interceptor, das Transportobjekt auszulesen und die bereitgestellten Informationen in den Aufrufkontext zu übertragen.

Mit dieser Voraussetzung können Service-Methoden durch die Annotation `@Gesichert` abgesichert werden.
Als Standard-Parameter werden alle Rechte aufgelistet, die eine Anfrage für einen Aufruf beinhalten muss.
Die Rechte sind immer konjunktiv verknüpft.
Eine disjunktive Verknüpfung von Rechten ist nicht möglich.

Alle Annotationen nutzen Spring AOP.
Daher sind sie nur an Methoden mit öffentlicher Sichtbarkeit (`public`) von Spring-Beans funktionsfähig.
Für HTTP-Invoker-Schnittstellen werden die Service-Methoden der Service-Implementierung (hinter der Exception-Fassade) mit den Annotationen ausgestattet.

Folgendes Beispiel zeigt die Implementierung einer Service-Methode, für die der Aufrufkontext automatisch ausgelesen und anschließend die Autorisierung gegen die Baustein Sicherheit durchgeführt wird.

:desc-listing-absichern-einer-service-methode: Absichern einer Service-Methode
[id="listing-absichern-einer-service-methode",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-absichern-einer-service-methode}
[source,java]
----
@StelltAufrufKontextBereit
@Gesichert("DialogA.Aufrufen", "DialogB.Aufrufen")
public void abgesicherteMethode(AufrufKontextTo kontext, ...) {
    ...
}
----

Erfüllt ein Aufrufer nicht die Forderungen der Annotation `@Gesichert`, so wird ein Fehler des Typs `AutorisierungFehlgeschlagenException` erzeugt.
Der Fehler wird in der Regel nicht lokal behandelt, sondern einfach zurückgegeben.
Letztlich deuten fehlende Rechte meist auf einen unberechtigten Zugriff oder einen Fehler in der Konfiguration einer aufrufenden Anwendung hin, so dass hier die normale Fehlerbehandlung greift.

[[batch-autorisierung]]
=== Autorisierung eines Batches

Beim Aufruf von Batches stellt der Batchrahmen das Auslesen des Aufrufkontextes und die Autorisierung des Batches sicher.
Zur Autorisierung ist im Batchrahmen bereits die Möglichkeit enthalten, einen Anwender zu konfigurieren.
Weitere Details zur Umsetzung der Autorisierung bei Batches sind in <<DetailkonzeptKomponenteBatch>> beschrieben.

[[batch-spring-konfiguration]]
==== Spring-Konfiguration

Zur Absicherung von Batches ist folgende, betriebliche Konfiguration erforderlich.

:desc-listing-batchbenutzer: Konfiguration zur Autorisierung von Batches
[id="listing-batchbenutzer",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-batchbenutzer}
[source,java]
----
batch.<batchname>.anwenderkennung = FAX_BAT_Fristenkontrolle
batch.<batchname>.anwenderpasswort = <secret>
batch.<batchname>.anwenderbehoerde = 4200
----

Neben der Kennung und dem Passwort kann auch eine Behörde (über eine ID oder Kennzeichen) angegeben werden, falls diese Information zur Authentifizierung oder zur Ermittlung der Rollen benötigt wird.
Weiterhin ermöglicht der Batchrahmen die Konfiguration von Benutzern für mehrere Batches über den Parameter `<batchname>`.

[[batch-absicherung]]
==== Absicherung eines Batches

Damit der Benutzer bei der Ausführung des Batches authentifiziert wird, muss die Methode `initialisieren` der Klasse `BatchAusfuehrungsBean`  mittels der Annotation `@Gesichert` geschützt werden.
Der Batchrahmen authentifiziert den Benutzer anhand der betrieblichen Konfiguration (s. <<batch-spring-konfiguration>>), erstellt einen neuen Aufrufkontext und speichert ihn im Verwalter.
Der eigentliche Prozess der Authentifizierung sowie die Ermittlung der Rollen ist für Nutzer des Batchrahmens vollständig transparent.

Des Weiteren muss die Methode `getAuthenticationCredentials` der Klasse `BatchAusfuehrungsBean` implementiert werden, damit der Batchrahmen den korrekten Anwender zur Authentifizierung nutzt.
So ist es möglich, neben dem üblichen Auslesen der Information aus der Konfiguration weitere Berechnungen oder Default-Werte anzugeben.

:desc-listing-benutzerdaten: Implementierungsbeispiel für die Versorgung des Batchrahmens mit Benutzerdaten
[id="listing-benutzerdaten",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-benutzerdaten}
[source,java]
----
@Override
public AuthenticationCredentials getAuthenticationCredentials(
    BatchKonfiguration konfiguration) {

    AuthenticationCredentials auth = new AuthenticationCredentials();

    auth.setBehoerdenkennzeichen(
        konfiguration.getAsString("batch.<batchname>.anwenderbehoerde"));
    auth.setBenutzerkennung(
        konfiguration.getAsString("batch.<batchname>.anwenderkennung"));
    auth.setPasswort(
        konfiguration.getAsString("batch.<batchname>.anwenderpasswort"));

    return auth;
}
----

Ab diesem Punkt kann der Batch jederzeit auf den Aufrufkontext zugreifen, um im Zuge des Batchlaufes Berechtigungsprüfungen vorzunehmen oder Services von Nachbarsystemen (vgl. <<aufrufen-von-nachbarsystemen>>) unter Bereitstellung des Aufrufkontextes aufzurufen.

[TIP]
====
In Ausnahmefällen ist es auch möglich, einen Batch zu implementieren, der ohne authentifizierten Benutzer laufen soll.
Dies ist allerdings nur möglich, wenn bei Aufrufen des Anwendungskerns keine Berechtigungsprüfungen stattfinden und keine Nachbarsystemschnittstellen aufgerufen werden.
In diesem Fall muss die Methode `getAuthenticationCredentials` so implementiert werden, dass sie `null` zurückgibt.
====

[[sgw-autorisierung]]
=== Autorisierung im Service-Gateway

Der Serviceanbieter eines Service-Gateways <<ServiceGatewaySystementwurf>> verwendet den Baustein Sicherheit, um den Benutzer einer eingehenden Anfrage zu authentifizieren und zu autorisieren.
Er verwendet dazu die Bibliothek `rf-sgw-util`, in der `isy-sicherheit` eingebunden ist.

Ein Service eines Service-Gateways wird aufgerufen.
Mit der Anfrage wird die Benutzerkennung des anfragenden Benutzers übermittelt.

Die im Service-Gateway verwendete Komponente Serviceanbieter nutzt den Baustein Sicherheit, um den anfragenden Benutzer bereits in der Informations- und Dienstezone zu authentifizieren.
Dazu benutzt der Serviceanbieter ein Client-Zertifikat, eine Benutzerkennung und ein Passwort.
Bei erfolgreicher Authentifizierung erstellt der Serviceanbieter einen neuen Aufrufkontext und speichert ihn im Verwalter.
Der eigentliche Prozess der Authentifizierung sowie die Ermittlung der Rollen ist für Nutzer des Service-Gateways vollständig transparent.

Das Service-Gateway übergibt den Fachanwendungen bei der Weiterleitung der Anfragen den Aufrufkontext als Transportobjekt an die jeweilige Service-Schnittstelle (vgl. <<aufrufen-von-nachbarsystemen>>).


// TODO Ab hier umschreiben!
[[autorisierung-im-anwendungskern]]
=== Autorisierung im Anwendungskern


_Durchführung der Autorisierungsprüfung_

Nach Übernehmen des `AufrufKontext` in den `AufrufKontextVerwalter` erfolgt die Autorisierungsprüfung dann über die Komponente Sicherheit.

Für die Autorisierungsprüfung stellt die `isy-sicherheit` neben dem Berechtigungsmanager (erlaubt Autorisierung per API-Aufruf) zusätzliche Hilfsmittel (Annotationen, Tags zur Verwendung in Flow-Definitionen) bereit, mit denen die Autorisierungsprüfung deklarativ erfolgen kann:

* Für Autorisierungen im Anwendungskern kann die Annotation `@Gesichert` oder direkt der `Berechtigungsmanager` verwendet werden.




Im Regelfall wird die Autorisierung einer Anfrage an den Schnittstellen der Anwendung durchgeführt.
Es ist jedoch bei Bedarf auch möglich, Prüfungen innerhalb des Anwendungskerns durchzuführen.

[[autorisierung-an-methoden-des-anwendungskerns]]
==== Autorisierung an Methoden des Anwendungskerns

Im Anwendungskern kann durch Verwendung der Annotation `@Gesichert` an Methoden des Anwendungskerns deklarativ festgelegt werden, wo eine Berechtigungsprüfung erfolgen soll.
Hier wird ausgewertet, welche Rollen und/oder Rechte der Benutzer haben muss, damit der Zugriff gewährt wird.
Die Anwendung fragt bei der Komponente Sicherheit die Rollen und Rechte des Benutzers ab und autorisiert die Anfrage.

Voraussetzung für das Funktionieren der Annotation `@Gesichert` ist, dass im Rahmen des Aufrufs der Anwendung der `AufrufKontextVerwalter` bereits gefüllt wurde.

[[autorisierung-in-methoden-des-anwendungskerns]]
==== Autorisierung in Methoden des Anwendungskerns

Prüfungen können auch ausprogrammiert werden.
Dabei wird die Komponente Sicherheit verwendet.
Hierzu wird das Bean Sicherheit in die Komponente des Anwendungskerns injiziert und der Berechtigungsmanager über die Methode `getBerechtigungsManager()` beschafft.
Der Berechtigungsmanager stellt die Methoden `getRechte()`, `getRecht()`, `hatRecht()` und `pruefeRecht()` bereit, mit denen die gewünschte Prüfung vorgenommen werden kann.

[[autorisierung-innerhalb-des-regelwerk]]
=== Autorisierung innerhalb des Regelwerk

Werden Regelwerke verwendet, so sind hier häufig Prüfungen zur Sichtbarkeit, Melde- und Auskunftsrechten, sowie von Primärdaten abhängigen Rechten umzusetzen.
Hierbei handelt es sich meist nicht um eine Autorisierung gegen Rollen, sondern um datenbezogene Prüfungen (z.B. Prüfung der Behördengruppe des Benutzers). Für diese Fälle gibt es keine Vorgaben, wie das zu erfolgen hat.
Sie können zum Beispiel innerhalb des Regelwerks als Regeln hinterlegt werden.

Soll innerhalb des Regelwerks auf Rollen geprüft werden, so ist eine individuelle Lösung unter Nutzung der Komponente Sicherheit möglich.

[[asynchrone-prozesse]]
==== Asynchrone Prozesse

Einige Anwendungen (z.B. Nachrichtenempfang an einem Email-Service-Gateway) verwenden asynchrone Prozesse, bzw.
starten Prozesse ereignis- oder zeitgesteuert.
Diesen Prozessen geht im Moment der Bearbeitung keine Benutzeranfrage voraus.
Daher kann die Bearbeitung im Regelfall nicht mit dem Aufrufkontext eines anfragenden Benutzers durchgeführt werden.
Stattdessen wird zum Start des Prozesses ein hinreichend berechtigter Benutzer (System) verwendet.
Es ist ein analoger Ablauf wie beim Start von Batches (siehe Kapitel <<autorisierung-eines-batches>>) umzusetzen.
Es ist eine analoge Konfiguration wie bei Batches (siehe Abschnitt <<konfiguration-2>>) vorzunehmen.




== Restliche Spring-Konfiguration

:desc-listing-konfiguration-fuer-spring: Konfiguration für Spring
[id="listing-konfiguration-fuer-spring",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-konfiguration-fuer-spring}
[source, xml]
----
<beans>
  <!-- @NutzerAuthentifizierung Annotation einschalten -->
  <bean id="nutzerAuthentifizierungInterceptor" class="de.bund.bva.pliscommon.sicherheit.annotation.NutzerAuthentifizierungInterceptor">
    <property name="aufrufKontextVerwalter" ref="aufrufKontextVerwalter"/>
    <property name="konfiguration" ref="konfiguration"/>
    <property name="sicherheit" ref="sicherheit"/>
  </bean>
  <aop:config>
    <aop:pointcut id="nutzerAuthentifizierungPointcut" expression="@annotation(de.bund.bva.pliscommon.sicherheit.annotation.NutzerAuthentifizierung) || @within(de.bund.bva.pliscommon.sicherheit.annotation.NutzerAuthentifizierung)"/>
    <aop:advisor pointcut-ref="nutzerAuthentifizierungPointcut" advice-ref="nutzerAuthentifizierungInterceptor"/>
  </aop:config>
  <!-- @StelltLoggingKontextBereit Annotation einschalten -->
  <bean id="stelltLoggingKontextBereitInterceptor" class="de.bund.bva.pliscommon.aufrufkontext.service.StelltLoggingKontextBereitInterceptor"></bean>
  <aop:config>
    <aop:pointcut id="stelltLoggingKontextBereitPointcut" expression="@annotation(de.bund.bva.pliscommon.aufrufkontext.service.StelltLoggingKontextBereit) || @within(de.bund.bva.pliscommon.aufrufkontext.service.StelltLoggingKontextBereit)"/>
    <aop:advisor pointcut-ref="stelltLoggingKontextBereitPointcut" advice-ref="stelltLoggingKontextBereitInterceptor"/>
  </aop:config>
</beans>
----



[[erzeugen-eines-berechtigungsmanagers]]
=== Erzeugen eines Berechtigungsmanagers
// TODO Umschreiben, so dass hier nur Entwicklungsaspekte übrig bleiben!

Die Komponente erzeugt für einen angegebenen Benutzer eine Instanz des Berechtigungsmanagers.
Der Berechtigungsmanager ist ein Container für die Berechtigungsinformationen des Benutzers, also für Rechte und Rollen.
Die Instanz des Berechtigungsmanagers kann auf mehrere Arten erzeugt werden:

`getBerechtigungsManager()`

Die Komponente Sicherheit ermittelt die Informationen zum Benutzer und zugehörige Rollen aus dem `AufrufKontextVerwalter` der Anwendung.
Diese Methode soll verwendet werden, wenn der Benutzer bereits in der Informations- und Dienstezone authentifiziert wurde und die Benutzerinformationen (inklusive Rollen) in der Anwendung im `AufrufKontextVerwalter` vorliegen.

`getBerechtigungsManagerUndAuthentifiziere +
(AufrufKontext unauthentifzierterAufrufkontext)`

Die Komponente Sicherheit authentifiziert zunächst den Benutzer durch eine Anfrage am Access-Manager, dabei werden die zur Authentifizierung benötigten Informationen über ein AufrufKontext-Objekt übergeben.
Für CAMS sind dies das Zertifikat (alternativ ZertifikatDn), Kennung und Passwort.
Der AccessManager ermittelt dann die Rollen des Benutzers und diese werden im `AufrufKontextVerwalter` der Anwendung hinterlegt.
Aus Sicht des CAMS erfolgt anschließend erfolgt sofort der Logout.

[[verwendung-des-berechtigungsmanagers]]
=== Verwendung des Berechtigungsmanagers
// TODO Umschreiben, so dass hier nur Entwicklungsaspekte übrig bleiben!

Der Berechtigungsmanager wird selten direkt im Programmcode verwendet, da die meisten Berechtigungsprüfungen deklarativ per Annotationen oder
Webflow-Tags (siehe Abschnitt <<autorisierung>>) umgesetzt werden.

Trotzdem kann eine Berechtigungsprüfung auch ausprogrammiert werden.
Dafür stellte die Komponente Sicherheit den Berechtigungsmanager mit folgender Schnittstelle bereit:

:desc-image-schnittstelle-des-berechtigungsmanagers: Schnittstelle des Berechtigungsmanagers
[id="image-schnittstelle-des-berechtigungsmanagers",reftext="{figure-caption} {counter:figures}"]
.{desc-image-schnittstelle-des-berechtigungsmanagers}
image::sicherheit_003.png[pdfwidth=45%,width=45%,align="center"]

Die Klasse Berechtigungsmanager bietet die folgenden Methoden an:

`getAktuellerBenutzer()`::
Liefert die Benutzerkennung des Benutzers (Login und Behörden-/Organisationskennzeichen) für den der Berechtigungsmanager erzeugt wurde.

`getRechte()`::
Diese Methode liefert eine Liste aller Rechte des Benutzers.

`getRecht()`::
Diese Methode liefert zu einer ID das zugehörige Recht, falls der Benutzer es besitzt.

`hatRecht()`::
Diese Methode prüft, ob der Benutzer das angegebene Recht hat.

`pruefeRecht()`::
Diese Methode prüft, ob der Benutzer das angegebene Recht hat und löste eine AutorisierungFehlgeschlagenException aus, wenn das nicht der Fall ist.

[[pruefung-der-erreichbarkeit-des-access-managers-ping]]
=== Prüfung der Erreichbarkeit des Access Managers (Ping)

Die Komponente Sicherheit bietet über das Bean SicherheitAdmin die Möglichkeit die Verfügbarkeit des Nachbarsystems Access-Manager zu prüfen.

:desc-image-schnittstelle-von-sicherheitadmin: Schnittstelle von SicherheitAdmin
[id="image-schnittstelle-von-sicherheitadmin",reftext="{figure-caption} {counter:figures}"]
.{desc-image-schnittstelle-von-sicherheitadmin}
image::sicherheit_004.png[pdfwidth=45%,width=45%,align="center"]

`pingAccessManager`::
Es wird ein Ping gegen den Access-Manager durchgeführt, um dessen Erreichbarkeit zu prüfen.
Diese Methode kann von nutzenden Anwendungen in die Watchdog-Test-Methode der Überwachung eingebunden werden.




[[aufrufen-von-nachbarsystemen]]
== Aufrufen von Nachbarsystemen
// TODO Umschreiben, so dass hier nur Entwicklungsaspekte übrig bleiben!

So wie eine Anwendung bei einem Aufruf erwartet, einen gültigen, vollständigen Aufrufkontext vorzufinden, erwartet dies auch ein Nachbarsystem, welches von der eigenen Anwendung aufgerufen wird.
Das aufrufende System muss daher einen Aufrufkontext mitliefern.
Im Regelfall soll dabei der Aufrufkontext der originären Anfrage verwendet und unverändert weitergeleitet werden.

Zum Aufruf des Nachbarsystems werden entweder die mit dem Nachbarsystem bereit gestellten Service-Client-Bibliotheken oder direkt die RemoteBean der aufzurufenden Schnittstelle verwendet.

Wenn ein Service über eine spezifische Client-Implementierung (z.B. den Schlüsselverzeichnis-Client) verwendet wird, so enthält diese (konform zum Berechtigungskonzept) bereits die Logik zur Weiterleitung des Aufrufkontextes.

Wenn der Service direkt über Spring HTTP-Invoker und das zugehörige RemoteBean-Interface aufgerufen wird, so ist die Weiterleitung des AufrufKontextes unter Nutzung des AufrufKontextVerwalters (per Spring injizieren) manuell zu programmieren.
Hierbei ist es wichtig, dass immer ein AufrufKontextTo-Objekt der Service-API verwendet wird, da nur dieses bei einem HTTP-Invoker-Aufruf im Server korrekt deserialisiert werden kann.

:desc-listing-weiterleitung-des-aufrufkontextes: Weiterleitung des Aufrufkontextes beim Serviceaufruf
[id="listing-weiterleitung-des-aufrufkontextes",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-weiterleitung-des-aufrufkontextes}
[source,java]
----
AufrufKontext aufrufKontext = aufrufKontextVerwalter.getAufrufKontext();
if (aufrufKontext == null) {
  throw new ...Exception(...);
}
remoteBean.methodeX((AufrufKontextTo) dozer.map(aufrufKontext, AufrufKontextTo.class, weitere, parameter);
----

Das Beispiel enthält folgende Schritte:

* Der `AufrufKontext` der Anwendung (dies ist meist eine anwendungsspezifische Implementierung des AufrufKontextes) wird vom `AufrufKontextVerwalter` abgerufen.
* Es wird ein Dozer-Default-Mapper verwendet, um das für Serviceaufrufe zu verwendende `AufrufKontextTo` der Service-API zu erstellen.
* Das erzeugte `AufrufKontextTo` der Service-API wird an die Schnittstelle des Service-Client übergeben.

[[verwendung-der-korrelations-id]]
== Verwendung der Korrelations-ID

Der `AufrufKontext` enthält auch die Korrelations-ID, die während der Bearbeitung einer Anfrage in der Anwendungslandschaft alle zusammen­ge­hö­ren­den Log-Ausgaben einer Anfrage durch eine gemeinsame ID kennzeichnet – auch wenn die Anfrage mehrere Teilsysteme der Anwendungslandschaft verwendet.
Dies erfordert eine Entgegennahme, Verwendung und Weiterleitung einer Korrelations-ID über alle Service-Aufrufe hinweg.
Details zum Aufbau der Korrelations-ID sind in <<NutzungsvorgabenLogging>> beschrieben.

Eine Korrelations-ID wird entweder bereits im eingehenden Aufruf mitgeliefert, oder muss neu erzeugt werden.

[[entgegennahme-der-korrelations-id-in-der-gui]]
=== Entgegennahme der Korrelations-ID in der GUI

Die Neuerzeugung und Registrierung der Korrelations-ID im MDC (_Mapped Diagnostic Context_) erfolgt automatisch innerhalb des `HttpHeaderParser` der Bibliothek `plis-sicherheit`-cams.

[[entgegennahme-der-korrelations-id-an-einer-service-sst]]
=== Entgegennahme der Korrelations-ID an einer Service-SST

Die Entgegennahme (ggf. Neuerzeugung) und Registrierung der Korrelations-ID im MDC erfolgt an der Exception-Fassade der Http-Invoker-Schnittstelle über die Annotation `@StelltLoggingKontextBereit` aus der Bibliothek `isy-serviceapi-core`.

[[ablage-und-weiterleitung-der-korrelations-id]]
=== Ablage und Weiterleitung der Korrelations-ID

Die Korrelations-ID wird für das Logging im MDC abgelegt.
Gleichzeitig wird diese jedoch auch im vom `AufrufKontextVerwalter` verwalteten `AufrufKontext` hinterlegt.
Ist dies der Fall, so wird die Korrelations-ID beim Aufruf des RemoteBeans des Nachbar­systems als Bestandteil des AufrufKontextes automatisch weitergeleitet.

[[verwenden-anwendungsspezifischer-aufrufkontexte]]
== Verwenden anwendungsspezifischer Aufrufkontexte

Gelegentlich möchte eine Anwendung zusätzliche Informationen im `AufrufKontextVerwalter` ablegen.
Hierzu lässt sich eine anwendungs­spezifische Spezialisierung des `de.bund.bva.pliscommon.kontext.AufrufKontextImpl` verwenden, der den `AufrufKontext` um zusätzliche Attribute erweitert.

:desc-listing-verwendung-des-aufrufkontextes: Verwendung eines anwendungsspezifischen AufrufKontext
[id="listing-verwendung-des-aufrufkontextes",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-verwendung-des-aufrufkontextes}
[source,xml]
----
<!—- Erstellt den anwendungsspezifischen `AufrufKontext` -->
  <bean
      id="aufrufKontextFactory"
      class="de.bund.bva.pliscommon.aufrufkontext.impl.AufrufKontextFactoryImpl">

    <property
      name="aufrufKontextKlasse"
      value="de.bund.bva.pliscommon.aufrufkontext.impl.<Anwendungsspezifisch>AufrufKontextImpl" />
  </bean>
----

Die zusätzlichen Attribute können bereits beim automatischen Befüllen des AufrufKontextVerwalters gesetzt werden.
So wäre es beispielsweise möglich, bei der Annahme eines Requests den Anfragezeitpunkt im Aufrufkontext festzuhalten.
Dazu kann eine anwendungsspezifische AufrufKontextFactory verwendet werden.

[[entwickeln-und-testen-ohne-access-manager-service]]
== Entwickeln und Testen ohne Access-Manager-Service

Hier wird erläutert, wie ein konfigurierbarer Stub des Aufruf­KontextVerwalters verwendet werden kann, um für eine in Entwicklung oder Test befindliche Anwendung das Vorliegen eines Aufrufkontextes (mit Informationen zu einem Benutzer und dessen Rollen) zu simulieren, obwohl bei einer Anfrage gar kein Aufrufkontext übergeben wurde.

Mit Hilfe dieses Stubs kann auf die Verwendung eines Access Managers in der Software-Entwicklungsumgebung verzichtet werden.
Der Stub gibt bei jeder Anfrage die statisch konfigurierten Benutzerdaten zurück.
Die Konfiguration erfolgt in _/resources/spring/querschnitt/sicherheit.xml_.

:desc-listing-konfiguration-aufrufkontext-stub: Konfiguration Aufrufkontext-Stub
[id="listing-konfiguration-aufrufkontext-stub",reftext="{listing-caption} {counter:listings }"]
.{desc-listing-konfiguration-aufrufkontext-stub}
[source,xml]
----
<!-- Verwende Stub Implementierung für die Entwicklung -->
<bean id="aufrufKontextVerwalter" class="de.bund.bva.pliscommon.
aufrufkontext.stub.AufrufKontextVerwalterStub" scope="request">
  <aop:scoped-proxy/>
  <property name="rollen">
    <list>
      <value><Rolle1, die der Benutzer im Test haben soll></value>
       <value><Rolle2, die der Benutzer im Test haben soll></value>
    </list>
  </property>
  <property name="durchfuehrendeBehoerde" value="42" />
  <property name="aufrufKontextFactory" ref="aufrufKontextFactory" />
</bean>
----

Neben der gezeigten Eigenschaft „Rollen“ und durchführende Behörde lassen sich auch alle weiteren Eigenschaften des Benutzers konfigurieren.

// end::inhalt[]