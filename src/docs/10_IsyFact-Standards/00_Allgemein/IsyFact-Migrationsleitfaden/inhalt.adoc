[[kapitel-anwendung]]
= Fachanwendung

== Applikationsklasse
* Für eine auf IsyFact 2.x basierende Anwendung wird eine _Applikationsklasse_ im Root-Package der Anwendung erstellt.
Siehe _Detailkonzept Komponente Anwendungskern -> Vorgaben zur Spring-Konfiguration_.

[source,java]
----
@SpringBootApplication
public class IsyFact2Application extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(IsyFact2Application.class);
    }
}
----


[[kapitel-web-xml]]
== web.xml

Die Änderungen an der Datei `web.xml` zusammengefasst:

.web.xml


----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd">

<web-app>
    <display-name>IsyFact2Application</display-name>


    <!-- Spring: Registration of ApplicationContext -->  <1>
    <!--context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
            classpath:resources/spring/application.xml,
            classpath:resources/spring/timertasks.xml,
            classpath:resources/spring/ueberwachung.xml,
            classpath:resources/spring/service/service.xml,
            classpath:resources/spring/service/remoting-servlet.xml
        </param-value>
    </context-param-->

    <context-param>
        <param-name>webAppRootKey</param-name>
        <param-value>IsyFact2Application</param-value>
    </context-param>

    <2>
    <!--context-param>
    	<param-name>logbackConfigLocation</param-name>
    	<param-value>classpath:/config/logback.xml</param-value>
    </context-param-->

    <!--listener>
    	<listener-class>ch.qos.logback.ext.spring.web.LogbackConfigListener</listener-class>
    </listener-->

    <3>
    <!--listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener-->

    <4>
    <!-- Servlet fuer HTTPInvoker-Aufrufe.
        Das Servlet nimmt die Aufrufe entgegen und verteilt sie auf die RemoteBeans.
        Die entsprechene Konfiguration befindet sich in remoting-servlet.xml -->
    <!--servlet>
        <servlet-name>remoting</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/classes/resources/spring/service/remoting-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet-->

    <5>
    <!--servlet>
        <servlet-name>loadbalancer</servlet-name>
        <servlet-class>
            de.bund.bva.pliscommon.ueberwachung.service.loadbalancer.LoadbalancerServlet
        </servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet-->

    <!--servlet-mapping>
        <servlet-name>loadbalancer</servlet-name>
        <url-pattern>/Loadbalancer</url-pattern>
    </servlet-mapping-->

    <6>
    <!--servlet-mapping>
        <servlet-name>remoting</servlet-name>
        <url-pattern>/MeldungBean_v1_0</url-pattern>
    </servlet-mapping>

    <servlet-mapping>
        <servlet-name>remoting</servlet-name>
        <url-pattern>/AuskunftBean_v1_0</url-pattern>
    </servlet-mapping>

</web-app>

----

<1> Entfällt. Die Konfiguration des Spring-Kontextes erfolgt über Java-Config / Component Scan.
<2> Entfällt. Siehe <<Logging>>.
<3> Entfällt. Der Spring-Kontext wird über `ServletInitializer` hochgefahren. Siehe <<Anwendung>>.
<4> Entfällt. Das Dispatcher-Servlet wird automatisch von Spring Boot konfiguriert.
Die Trennung von Web- und Anwendungskontext entfällt.
<5> Entfällt. Siehe <<Überwachung>>.
<6> Entfällt. Beans vom Typ `HttpInvokerServiceExporter` werden automatisch von Spring Boot konfiguriert.
Der Pfad für das Mapping wird vom Namen der Bean abgeleitet. Siehe <<Service>>.
[source,java]
----
@Bean(name = "/AuskunftBean_v1_0")
public HttpInvokerServiceExporter meldung() {
----

[[kapitel-test]]
== Test
[source,java]
----
@RunWith(SpringRunner.class)
@SpringBootTest(classes = RaumplanungApplication.class)
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class, TransactionDbUnitTestExecutionListener.class})
@DatabaseSetup("eintraege.xml")
public class EintragControllerTest {
----

[[kapitel-bausteine]]
= Bausteine

[[kapitel-spring-konfiguration]]
== Spring Konfiguration

* Die Konfiguration von Spring wird von XML auf Java-Config umstellt.
Siehe _Detailkonzept Komponente Anwendungskern -> Vorgaben zur Spring-Konfiguration_.
* Für die betriebliche Konfiguration wird `application.properties` anlegt.
Siehe _Detailkonzept Komponente Anwendungskern -> Konfigurationsparameter über Property-Objekte konfigurieren_.

[[kapitel-konfiguration]]
== Konfigurationsparameter

* Die Bereitstellung von Konfigurationsparametern erfolgt über `@ConfigurationProperties`-Klassen.
Soll die Bibliothek `isy-konfiguration` weiterhin verwendet werden, muss die Bean aus der Spring-Konfiguration entfernt werden.
Die Liste mit den Property-Dateien wird nach `application.properties` übertragen.
* Siehe _Konzept Überwachung und Konfiguration -> Verwendung von isy-konfiguration_.

[[kapitel-persistenz]]
== Persistenz

* Die Spring-Konfiguration für die Persistenz muss geändernt werden (_EntityManager_, _DataSource_).
Ebenso wird die betriebliche Konfiguration aus `jpa.properties` nach `application.properties` übertragen.
Siehe  _Detailkonzept Komponente Anwendungskern -> Konfiguration von JPA über Spring Beans durchführen_.
Verweis auf Doku
* Sollen die alten DAOs aus `isy-persistence` weitergenutzt werden, dann diese als Beans in Java-Config übernommen werden.

[[kapitel-logging]]
== Logging

* Die Konfiguration des Loggings erfolgt über `logback.xml` und zusätzliche Properties in `application.properties`.
Die Datei `logback.xml` liegt unter `src/main/resources`.
Die Änderung der Log-Level erfolgt über `application.properties`, diese werden nicht in `logback.xml` angegeben.
* Siehe _Nutzungsvorgaben Logging -> Logback-Konfiguration_.
* Der `LogbackConfigListener` entfällt komplett, d.h., die Abhängigkeit in `pom.xml` und die Konfiguration in `web.xml` sind nicht notwendig.
* Interceptoren für System- und Komponentengrenzen und der `LogApplicationListener` werden per Autokonfiguration erstellt und müssen der Spring-Konfiguration entfernt werden.
Die System- und Komponentengrenzen werden nicht über manuell konfigurierte Pointcuts, sondern über die Annotation `@Systemgrenze`  und `@Komponentengrenze` festgelegt.
* Die Konfiguration der Interceptoren für das Logging an System- und Komponentengrenzen (wenn abweichend von der Default-Konfiguration) über Properties in `application.properties` nach dem Schema:
* Siehe _Nutzungsvorgaben Logging -> Spring-Konfiguration_.
* Die Konfiguration des `LogApplicationListener` erfolgt über Properties in `application.properties`:
* Siehe _Nutzungsvorgaben Logging -> LogApplicationListener_.

.application.properties
[source]
----
isy.logging.anwendung.name=Anwendung
isy.logging.anwendung.version=2.0.0
isy.logging.anwendung.typ=GA
----
* Aktivieren des Performance Loggings über `isy.logging.performancelogging.enabled=true` in `application.properties`.
* Siehe _Nutzungsvorgaben Logging -> Performance-Logging_.

[[kapitel-ueberwachung]]
== Überwachung

* `isy-ueberwachung` setzt _Spring Boot Actuator_ und _micrometer_ ein.
* Die Überwachungsinformationen für Services werden über _micrometer_ bereitgestellt.
Die eigentliche Überwachung erfolgt über einen AOP-Advice. Dieser wird per Java-Config konfiguriert:
* Siehe _Konzept Überwachung und Konfiguration -> Informationen von Services_.
* Die Implementierung von Ping- und Prüfmethoden wird über `HealthIndicator` realisiert.
* Siehe _Konzept Überwachung und Konfiguration -> Vorgaben für die Prüfung der Verfügbarkeit_.
* Die Verbindung zur Datenbank wird von einem `HealthIndicator` aus `isy-persistence` überwacht.
Eine eventuell vorhandene manuelle Prüfung kann entfernt werden.
* Das Loadbalancer-Servlet wird automatisch konfiguriert und der Eintrag in `web.xml` kann entfernt werden.
* Siehe _Konzept Überwachung und Konfiguration -> Integration des Loadbalancer-Servlets_.

[[kapitel-polling]]
== Polling

* Die Konfiguration (Polling-Cluster und JMX-Verbindungen) müssen nach `application.properties` überführt werden.
* Siehe _Nutzungsvorgaben Polling -> Konfiguration über Properties_.
* Die Beans für den Polling-Verwalter und die Interceptoren für `@PollingAktion` müssen entfernt werden.
* Siehe _Nutzungsvorgaben Polling -> Spring-Konfiguration_.

[[kapitel-batchrahmen]]
== Batchrahmen

* Die Spring-Konfiguration muss in Java-Config überführt werden.
Eine gesonderte Konfiguration des Anwendungskontextes für den Batchrahmen ist nicht zwingend notwendig.
Um Beans aus der Spring-Konfiguration der Anwendung für die Ausführung eines Batches auszuschließen, kann die Annotation (`@ExcludeFromBatchContext`) verwendet werden.
* Siehe _Detailkonzept Komponente Batch -> Die Konfiguration der Spring-Kontexte_.
* In der Property-Dateien zur Konfigration der Batches werden statt XML-Konfigurationsdateien die vollqualifizierten Namen der Java-Konfigurationsklassen eintragen.
* Siehe _Detailkonzept Komponente Batch -> Konfigurationsdatei und Kommandozeilen-Parameter_.



[[kapitel-sicherheit]]
== Sicherheit

* Bei der Überführung in Java-Config können bestimmte Beans entfernt werden.
Automatisch konfiguriert werden die `@Gesichert`-Annotation, die `AufrufKontextFactory` und die Thread-Scopes `thread` und `request` für Spring.
* In der Anwendung müssen die Beans für `AufrufKontextVerwalter`, `Sicherheit` und `AccessManager` konfiguriert werden.
* Siehe _Nutzungsvorgaben Sicherheit -> Grundkonzepte und Konfiguration -> Spring-Konfiguration_.
* Der Konfiguration des Caches für Authentifizierungen erfolgt in `application.properties`.
* Siehe _Nutzungsvorgaben Sicherheit -> Caching von Authentifizierungen_.

[[kapitel-task]]
== Task

* Das Einbinden der XML-Spring-Konfiguration entfällt.
Die Verwendung von `isy-sicherheit` wird mit einer Property in `application.properties` gesteuert.
* Siehe _Nutzungsvorgaben Task Scheduling -> Spring Konfiguration_.
* Die Properties zur Konfiguration der Tasks müssen nach `application.properties` übertragen werden.
* Siehe _Nutzungsvorgaben Task Scheduling -> Konfigurationsschlüssel_.

[[kapitel-service]]
== Service

* Die Konfiguration der HttpInvoker muss nach Java-Config überführt werden.
* Beans vom Typ `HttpInvokerServiceExporter` werden automatisch von Spring Boot konfiguriert.
Der Pfad für das Mapping wird vom Namen der Bean abgeleitet.
[source,java]
----
@Bean(name = "/AuskunftBean_v1_0")
public HttpInvokerServiceExporter meldung() {
----

